
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Carte avec filtre saison et itin√©raire</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map { height: 100vh; }
    .leaflet-control-custom, .leaflet-control-filters {
      background-color: white;
      border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.65);
      font-size: 14px;
      padding: 6px;
      cursor: pointer;
    }
    .emoji-marker {
      background-color: white;
      border-radius: 50%;
      box-shadow: 0 1px 4px rgba(0,0,0,0.6);
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }
  </style>
</head>
<body>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
const map = L.map('map').setView([47.905, 7.175], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

const currentMonth = new Date().getMonth(); // 0 = janvier

function isCurrentlyOpen(periode) {
  if (!periode || periode === 'toute l'ann√©e') return true;
  const match = periode.match(/(\d{1,2})\s*(\w+)\s*[-√†]\s*(\d{1,2})\s*(\w+)/);
  if (!match) return true;
  const mois = { janvier: 0, f√©vrier: 1, mars: 2, avril: 3, mai: 4, juin: 5,
                 juillet: 6, ao√ªt: 7, septembre: 8, octobre: 9, novembre: 10, d√©cembre: 11 };
  const start = mois[match[2].toLowerCase()];
  const end = mois[match[4].toLowerCase()];
  return start <= end
    ? currentMonth >= start && currentMonth <= end
    : currentMonth >= start || currentMonth <= end;
}

let allFeatures = [];
let markerLayer;
let itineraryLayer;

function loadPoints() {
  fetch('points-eau-typed.geojson')
    .then(res => res.json())
    .then(data => {
      allFeatures = data.features;
      showMarkers(allFeatures);
    });
}

function showMarkers(features) {
  if (markerLayer) map.removeLayer(markerLayer);
  markerLayer = L.layerGroup();
  features.forEach(f => {
    const emoji = {wc: 'üöª', fontaine: '‚õ≤', source: 'üí¶', commerce: 'üõí'}[f.properties.type] || '‚ùì';
    const marker = L.marker(f.geometry.coordinates.reverse(), {
      icon: L.divIcon({className: 'emoji-marker', html: emoji, iconSize: [30, 30], iconAnchor: [15, 15]})
    }).bindPopup(`<b>${f.properties.titre}</b><br>${f.properties.description}`);
    markerLayer.addLayer(marker);
    f.geometry.coordinates.reverse(); // Reset to original [lon, lat]
  });
  markerLayer.addTo(map);
}

function filterOpen() {
  const filtered = allFeatures.filter(f => isCurrentlyOpen(f.properties.periode));
  showMarkers(filtered);
}

function createItineraryToClosest(userLatLng) {
  let closest = null, minDist = Infinity;
  allFeatures.forEach(f => {
    const latlng = L.latLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
    const dist = map.distance(userLatLng, latlng);
    if (dist < minDist) {
      minDist = dist;
      closest = latlng;
    }
  });

  if (!closest) return;

  const url = `https://router.project-osrm.org/route/v1/foot/${userLatLng.lng},${userLatLng.lat};${closest.lng},${closest.lat}?overview=full&geometries=geojson`;

  fetch(url)
    .then(res => res.json())
    .then(data => {
      const coords = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
      if (itineraryLayer) map.removeLayer(itineraryLayer);
      itineraryLayer = L.polyline(coords, {color: 'green'}).addTo(map);
      map.fitBounds(itineraryLayer.getBounds());
    });
}

L.control.custom = function(opts) {
  const control = L.control({position: opts.position});
  control.onAdd = function(map) {
    const div = L.DomUtil.create('div', 'leaflet-control-custom');
    div.innerHTML = opts.html;
    div.onclick = opts.onClick;
    return div;
  };
  return control;
};

L.control.custom({
  position: 'topright',
  html: 'üîÑ Points ouverts actuellement',
  onClick: filterOpen
}).addTo(map);

L.control.custom({
  position: 'topleft',
  html: 'üìç Me localiser',
  onClick: function() {
    map.locate({setView: true, maxZoom: 16});
  }
}).addTo(map);

map.on('locationfound', function(e) {
  L.marker(e.latlng).addTo(map).bindPopup("üìç Vous √™tes ici").openPopup();
  createItineraryToClosest(e.latlng);
});

map.on('locationerror', function(e) {
  alert("G√©olocalisation impossible : " + e.message);
});

loadPoints();
</script>
</body>
</html>
